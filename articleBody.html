<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8">
  <title>Git for Non-Programmers</title>
</head>
<body>
<h1 style="width: 763px;">Version Control and Git for
Non-Programmers</h1>
<h2>Introduction</h2>

<p>This article introduces <a href="http://en.wikipedia.org/wiki/Version_Control">version control</a> and <a href="http://git-scm.com/">Git</a> without assuming you have any prior knowledge or programming experience. Because of its introductory nature, certain details are simplified or omitted and the use of the Git Graphical User Interface (<a  href="http://www.kernel.org/pub/software/scm/git/docs/git-gui.html">Git GUI</a>) is emphasized. Afterwards the reader should be able to use Git for basic version control and know where to locate further information.</p>

<p><i>Version control</i> is the process of recording the history of changes to files as they are modified. Users can go back in time and get old versions and identify where changes were introduced (people sometimes refer to version control tools as time machines). This means that it's easier to:</p>
<ul>
  <li>protect against changes -- accidental or otherwise -- and be able to access a known good version of a file</li>
  <li>track down problems and make fixes to previous versions of files</li>
  <li>allow more than one person to modify project files simultaneously (programmers refer to this as parallel development)</li>
  <li>retrieve an older set of files (if requested by a customer or manager, for example)</li>
</ul>
<p>The first version control (VC) tool, <a href="http://en.wikipedia.org/wiki/Source_Code_Control_System">SCCS</a>, was written in 1972 and since that time there have been major advances in the way VC tools are used. Git represents the current <em>state of the art</em> in that it is distributed. A distributed VC tool gives each user a complete history of all changes to the files on which they work. So, for instance, it's possible to look at previous versions of files while flying across the Pacific (depending on your laptop battery too, of course). Later, when you touch down, all changes can be merged together over the computer network for release or further work. This may sound complicated, but the tool makes it relatively easy and error free.</p>  

<p>Other well-known VC tools -- for example <a href="http://svnbook.red-bean.com/nightly/en/index.html">Subversion</a> -- are classed as centralized and provide only a single place, the repository, into which users store their changes on a regular basis. In this model users work without a personal copy of the change history; they only have the set of the files they're currently working with.
</p>

Git runs on Windows, Mac OS X, Linux and UNIX. It was developed by Linus Torvalds, the lead developer of Linux, in 2005 to answer the needs of the development community. As well as a powerful tool for the individual developer, it provides a powerful model for cooperation. Community source code sharing sites like <a href="https://github.com/">GitHub</a> and <a href="http://gitorious.org/">Gitorious</a> make full use of its capabilities.</p>


<h2>Concepts</h2>
<p>Git maintains a database of all previous file versions in a repository (<em>repo</em> in geek speak) and it is usually located in a directory called <code>.git</code>. In UNIX-style systems (like Mac OS X and Linux) names that begin with a <code>.</code> are hidden by default so the repo is usually invisible during normal work (except on Windows). As well as the contents of the files and directory versions the repo contains additional housekeeping information about current work, other remote repositories we're sharing with, current settings, and so on. In Git we have a separate repo for each of our projects.</p>

<p>In addition to the repo, each project will have a set of files that we're working on and editing. As we complete changes to our working files we add the changes to the repo; this is called <em>committing</em> changes. In actual fact we're not fully committed to our changes as we can always retrieve old versions and make changes to the changes. We can also access a summary of our work against previous versions to see what we've done so far. The set of files we're currently working on is called the <em>working copy</em>. We can easily change the working copy to a different version whenever we want.</p>

<h2>Installing Git</h2>
<p>Before progressing any further let's install Git and set up a small test repo to work with.</p> 

<p>If you use Linux then installing should be a simple matter of using your package manager to install git (and possibly Git GUI if it is a separate package). For Mac OS X either use the <a href="http://code.google.com/p/git-osx-installer/">Git OSX Installer</a> or you can use <a href="http://github.com/guides/get-git-on-mac">Mac Ports</a>. Windows users who use <a href="http://www.cygwin.com/">Cygwin</a> can use the Git from Cygwin; just use the Cygwin package manger to install the appropriate packages. Otherwise Windows users should use the the <a href="http://code.google.com/p/msysgit/downloads/list">native Windows Git package: msysgit</a> (you'll want to download the file labelled "  	 <em>Full installer if you want to use official Git..</em>" and avoid the file labelled "<em>Full installer (self-contained) if you want to hack on Git</em>" and accept all the installation defaults). </p>

<h2>Starting to Use Git</h2>
<p>The quickest way to get started is to use the Git GUI client. If you use Windows you'll find <strong>Git GUI</strong> on your Start menu, otherwise you can type the command <code>git gui</code> at the command prompt. You'll see a screen similar to this:</p>

<img alt="Git Gui startup screen" src="images/git-gui-startup.png">.

<p>Select <strong>Create New Repository</strong> and enter the name of a new directory. Git will create the directory and initialize an empty repo. Alternatively, create a project directory, and then within the new directory enter the following from the command prompt:</p>
  
<pre><code>$ git init</code></pre>

<p>If you're on Mac OS X or Linux you can just use the standard terminal. If you're on Windows and you've installed the msysGit package, then you'll find the <strong>Git Bash</strong> item on your Start menu. This will launch a special command prompt for using Git. Exclude the <code>$</code>, that represents the command prompt, but enter in everything after it.</p>

<p>You should then see a message like the following:</p>

<pre><code>Initialized empty Git repository in /path/to/your/directory/.git/</code></pre>

<p>If you look in the project directory you should see a directory named <code>.git</code> (on Mac OS X or Linux you will need to use the command <code>ls -A</code> to show the hidden <code>.git</code> directory) In your newly created project directory make some new text files using your favorite editor. You now have some changes that are not under version control, in Git these are called <em>unstaged</em>. In Git GUI they look should like this:</p>

<img alt="Unstaged Changes" src="images/git-gui-unstaged-changes.png">

<p>You can retrieve the same information from the command line with the command <code>git status</code>.</p>

<img alt="git status" src="images/git-bash-status.png">

<p>Now for a little diversion before we add our files to the repository: the <em>Git index</em>.</p>

<h2>The Git Index</h2>
<p>Git is a little different to most VC tools in that adding changes to a repo is a two stage process. All changes are <em>staged</em> in the index, before they're committed into the repo.</p>

<img alt="Working vs Index vs Repo" src="images/git-index-diag.png">

<p>The index allows us to add, remove and modify changes on the way to building a commit. While the index may seem confusing and unnecessary at first, it is useful for a variety of reasons:</p>

<ol>
  <li>Our working copy may contain more that one set of changes and the index allows us to cherry pick which ones will be part of the next commit.</li>
  <li>You can incrementally make changes (using your own workflow) before making a commit.</li>
  <li>You're able to stage and unstage changes in more complex work flows (this is a little advanced for this intro but if you're curious see <a  href="http://www.kernel.org/pub/software/scm/git/docs/git-stash.html">git stash</a>).</li>
</ol>

<p>Whenever we have file changes the <code>git add</code> command is used to add the content to the index. As well as
<code>add</code> there is also the <a  href="http://www.kernel.org/pub/software/scm/git/docs/git-rm.html">git rm</a> command to remove files and the <a  href="http://www.kernel.org/pub/software/scm/git/docs/git-mv.html">git mv</a> file to move or rename files. Once we've added the appropriate changes to the index we can commit changes to the repo.</p>

That's all I'll mention about the index here, we'll just go ahead and use it now. However, before we can do that we have to sort out a configuration issue.

<h2>Configuration</h2>
<p>Before using Git we need to tell Git who we are; our name and email address. From the Git GUI interface select <strong>Edit &gt; Options</strong> and fill in the top two fields under Global. Leave all the other values as they are</p>

<img src="images/git-gui-config.png" alt="Set Global details"><br>

You can alternately run the commands
<pre><code>$ git config --global user.name "Alec Clews"
$ git config --global user.email "alec.clews@voga.com.au"</code></pre>

<h2>Committing Changes</h2>

<p><em>Now</em> we can add our changes to the index and commit them to the repository. First select both files on the <strong>Unstaged Changes</strong> pane.</p>

<img alt="Select Files for staging" src="images/git-gui-unstaged-changes-panel.png">

<p>Then select <strong>Commit > Stage To Commit</strong> (ctrl+T). The display then shows that we have no changes waiting to be
staged, but we do have changes to be committed.</p>

<img alt="Files to be committed" src="images/git-gui-staged.png">
 
<p>Alternatively you can run the following command</p>

<pre><strong>$ git add file1 file2</strong></pre>

<p>You can also use the following if it's unnecessary to specify which files to add: </p>

<pre><code>$ git add .</code></pre>

<p>Now that our files are staged, we can commit our first changes to the repo. Each time we make a commit, Git expects an informational message that's added as part of the commit; if fail to provide a message no commit will be made. Generally we add a single line description and then a more detailed message. Click the <strong>Commit</strong> button and the changes are committed to the repo.</p>

<img alt="Git GUI commit example" src="images/git-gui-staged-commit.png"><br>

Alternatively from the command line you can enter the following:

<pre><code>$ git commit -m "A message about your changes"</code></pre>  
  
<p>Now that we've made a commit, the latest version in the repo -- called <code>HEAD</code> -- is the same as the contents of the working files. Running the command <code>git status</code> should show the message:</p>

<pre><code>$ git status
# On branch master
nothing to commit (working directory clean)</code></pre>

<p>We can always refer to the contents of the last commit as <code>HEAD</code> and the contents of the commit prior to that as <code>HEAD^1</code> (and <code>HEAD^2</code> for the commit prior to that, and so on). However that quickly becomes error prone and hard to use, so Git gives each commit a special id which is an apparently random string of 40 characters called the <strong>sha1 hash</strong>. It  looks a like this: <code>a90973cbe16d5a0cf4fcd5cca659f4a4587d7cb5</code>.</p>
  
<p>While it may look a bit user unfriendly every commit across the world has a unique sha1 hash and when you come to share your history with other Git users (for instance, other members of the web team) it's a unique way to refer to your work and its history. If two users have the same sha1 in their repo then they are referring to the same piece of work. In practice, humans can usually just refer to the last few unique digits in the sha1 to uniquely identify a commit.</p>

<p>As a user you'll generally only see a sha1 hash used to represent a commit; however, "under the covers" the hash is used to identify files and directories (which form <em>trees</em> in Git terminology), and other objects. This has an interesting, and highly desirable, effect. When you rename a file (or move it in the directory tree) its sha1 hash remains unchanged, but the tree that refers to the file and its name changes. This means that Git can track changes and moves far more easily than tools such as Subversion.</p>

<p>Now, lets make another change. Pretend you've done some work and make a change to one of the files. Git GUI will show you the changes:</p>

<img alt="Showing diffefrences in Git GUI" src="images/git-gui-unstaged-changes-2.png">

<p>You can also run the command <code>git diff</code> to show the changes in your terminal window. We can continue to add and commit changes as before.
  
<p>To view the history of commits to a project you can use the command <code>git log</code>. Git also has a second GUI application called gitk that displays the history of commits in a graphical format. In Git GUI select <strong>Repository > Visualize All Branch History</strong>.</p>

<img alt="Visualize the history" src="images/git-gui-history-viz.png">

<h2>Branches and Merges</h2>
<p>One of Git's most powerful features is support for easy branching and merging of files. If you look back over the previous examples you'll see references to <em>master</em>. This is the name of the default branch and every time we make changes they'll be added to the history of the master branch. However life rarely proceeds in a straight line -- instead, we're forced to jump around and work on different versions of our project. Git makes this a lot easier than you would think.</p>

<p>Suppose we have a web site that's currently in production. That work will be maintained on the master branch as the current production release: the working web site. We now have to prepare new changes for the next release of the web site and also fix issues that came up in that last production release. (and probably a million other things as well!)</p>

<p>We can represent this in Git by having three branches:</p>
<ul>
  <li><code>master</code>: what's in production or about to be released to production</li>
  <li><code>development</code>: our new set of features for the next release; we'll call this one <em>rel_2</em></li>
  <li><code>maintenance</code>: a copy of the master previously released to production that we use to make and test immediate fixes to the live site</li>
</ul>

<p>Let's set up another example and see it in action. Create a new repository as we did previously, and add a file called <code>index.html</code> with the source as follows:</p>

<pre><code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;hello world&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Now add and commit the file with the message <em>Initial Production version</em>. This is our release version of the web site. If you're curious as to how to make a release, see <a  href="http://www.kernel.org/pub/software/scm/git/docs/git-archive.html"><code>git archive</code></a>. All is right with the world and we come in the next day and start working on new features. So that we don't disturb the production code we create a new branch. You can do this in Git GUI by selecting <strong>Branch &gt; Create...</strong> and giving it a name. Doing it from the command line is just as easy:</p>

<pre><code>$ git branch rel_2</code></pre>

<p>There are now two branches in our project. Changes on one branch are independent of the history recorded on the other branch. We can list the branches like this:</p>

<pre><code>$ git branch
  * master
    rel_2
</code></pre>

<p>The branch you are working on is called the <em>active</em> branch, and is marked with an asterisk. The <code>git checkout</code> command is used to switch between branches in order to work on them. Enter the following command:</p>

<pre><code>$ git checkout rel_2</code></pre>

<p>You can also use Git GUI; select <strong>Branch &gt; Checkout</strong> and you'll be given a list of branches to select from. For your information both the <code>git status</code> and <code>git branch</code> commands will indicate the currently active branch, as will the Git GUI window.</p>

<pre><code>$ git branch
    master
  * rel_2
</code></pre>

<pre><code>$ git status
# On branch rel_2
# ...
</code></pre>

Now let's make some changes for the next web site release. Edit <code>index.html</code> and add the following:

<pre><code>...
  &lt;h1&gt;hello World&lt;/h1&gt;
  &lt;h2&gt;Goodbye World&lt;/h2&gt;
...</code></pre>

<p>We can see summary of the changes in Git GUI or by using <code>git diff</code> on the command line:</p>

<img alt="Diff display" src="images/git-gui-prod-rel2-unstaged.png">

<pre><code>$ git diff
diff --git a/index.html b/index.html
index 1d02625..e7973bc 100644
--- a/index.html
+++ b/index.html
@@ -4,5 +4,6 @@
   &lt;/head&gt;
   &lt;body&gt;
     &lt;h1&gt;hello world&lt;/h1&gt;
+    &lt;h2&gt;Goodbye World&lt;/h2&gt;
   &lt;/body&gt;
 &lt;/html&gt;</code></pre>

<p>Lines that begin with the plus symbol (<code>+</code>) indicate the additions that have not been staged. <code>git diff</code> has a variety of options that allow you display changes between the working copy, index and various revisions. Type <code>git diff --help</code> at the command prompt for more information. Incidentally, all Git commands support the <code>--help</code> option.</p>

<p>Stage and commit the changes and we're done. If you use the command line you may like to know that you can do all that with only one command:</p>

<pre><code>$ git commit -a -m "say goodbye"</code></pre>

<p>...as well as gain feedback about the committed changes:</p>

<pre><code>[rel_2 0015d91] say goodbye
1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>

<p>Git is telling us that:</p>

<ol>
  <li>a new commit on the branch <em>rel_2</em> with a sha1 hash starting 0015d91 was created with the message "say goodbye"</li>
  <li>it has tracked a change to one file</li>
  <li>the file change consisted of one line inserted</li>
</ol>

<p>Running the <code>git log</code> command summarizes the previous two commits</p>

<pre><code>$git log
commit 0015d91c6d24f6d43627bf45af82ee2085fbfc5d
Author: Alec Clews <alec.clews@voga.com.au>
Date: Wed Jul 29 09:38:51 2009 +1000

 say goodbye

commit e74e1271907baf14a4cd5c2d7724373face011d6
Author: Alec Clews <alec.clews@voga.com.au>
Date: Mon Jul 27 22:05:06 2009 +1000

 Initial Production version</code></pre>

<p>We can aslo see the history with the Git GUI visualization tool</p>

<img alt="first commit for rel 2" src="images/git-gui-prod-rel2-history.png"><br>

<p>Now lets simulate a fix to the production release code without affecting our work in progress on the <em>rel_2</em> branch. Remember that the master branch is the current copy of our production code, so let's move our working copy back to production (our recent changes are safe on the <em>rel_2</em> branch).</p>

<pre><code>$ git checkout master
Switched to branch 'master'</code></pre>

<p>If you're using Git GUI, then select <strong>Branch &gt; Checkout...</strong>. So, we've returned to the master branch, let's create a new branch for production support and switch to it:</p>

<pre><code>$ git branch prod_support
$ git checkout prod_support
Switched to branch 'prod_support'
$ git branch
  master
* prod_support
  rel_2
</code></pre>

<p>So now we have three branches and we're working on the prod_support branch (because that is the last branch we checked out). Edit <code>index.html</code> (capitalize the <em>H</em> in <em>hello</em>) and then commit the changes. Using the visualization tool from Git GUI we can see all the branches.</p>

<img alt="gitk displays multiple branches" src="images/git-gui-prod-support-history.png">
 
 
Because we're working on the prod_support branch we can now test our changes in isolation. If all is well we'll want to apply those changes to the master branch so we can release them to production. This operation is called <em>merging</em>. First we need to checkout the master branch and then we can merge in the changes from the prod_support branch. Use <strong>Branch &gt; Checkout...</strong> in Git GUI, or the following command:

<pre><code>$ git checkout master</code></pre>

To merge the changes in Git GUI use <strong>Merge &gt; Local Merge...</strong>, select the prod_support branch from the list, and click the <strong>Merge</strong> button.  Or, from the command line, enter the following:

<pre><code>$ git merge prod_support  -m "Update production with fix from support"</code></pre>

<p>If we look at our history visualization again we can see the effect of the merge.</p>

<img alt="After a merge" src="images/git-gui-prod-support-history-merged.png">
 
<p>Now that the fix has been released into production, we can return to working on the rel_2 branch:</p>

<pre><code>$ git checkout rel_2</code></pre>


<h2>Wrap Up</h2>
<p>This has been but a very brief tour to introduce the power of Git. There are lots of really great resources to start you off (some of which are listed below). So why would you want to take Git to the next level?</p>
<ol>
  <li>It can run without a network or a central server.</li>
  <li>It's very fast.</li>
  <li>It's extremely powerful and flexible.</li>
  <li>It encourages collaboration with the your colleagues and the rest of the world through services like GitHub and Gitorious.</li>
</ol>
<p>All very sound reasons to explore Git further.</p>

<h3>Further Reading</h3>
<ul>
  <li>The <a href="http://learn.github.com/p/intro.html">introductory tutorial video and other material at Github</a> are excellent.</li>
  <li>The <a href="http://git-scm.com/">main Git site</a> has lots of documentation.</li>
  <li>The <a href="http://www.kernel.org/pub/software/scm/git/docs/v1.5.4.5/tutorial.html">official Git tutorial can be found at http://www.kernel.org</a>.</li>
  <li>I also maintain <a href="http://delicious.com/alecclews/git">a list of useful Git links on Delicious</a>.</li>
</ul>



<h2>About the author</h2>
Alec Clews is principal consultant at Voga Consulting Services (http://voga.com.au) where he specialises in SCM and Application Life-cycle
Management. You can connect to him at http://www.linkedin.com/in/alecclews, have a conversation with him as alecthegeek on twitter and identi.ca, or find his code at http://github.com/alecthegeek.


<h2>Copyright</h2> This article is copyright © 2009 SitePoint Pty. Ltd. All Rights
Reserved. Join the discussion at
http://sitepoint.com/launch/git-tutorial/
</body>
</html>
